{"ast":null,"code":"import IMask, { pipe } from 'imask';\nexport { default as IMask, PIPE_TYPE, pipe } from 'imask';\nimport { isPlatformBrowser } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, inject, forwardRef, ElementRef, Renderer2, PLATFORM_ID, EventEmitter, Directive, Input, Output, Pipe, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE } from '@angular/forms';\nlet DefaultImaskFactory = /*#__PURE__*/(() => {\n  class DefaultImaskFactory {\n    create(el, opts) {\n      return IMask(el, opts);\n    }\n    static #_ = this.ɵfac = function DefaultImaskFactory_Factory(t) {\n      return new (t || DefaultImaskFactory)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DefaultImaskFactory,\n      factory: DefaultImaskFactory.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return DefaultImaskFactory;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst IMASK_FACTORY = new InjectionToken('IMASK_FACTORY', {\n  providedIn: 'root',\n  factory: () => inject(DefaultImaskFactory)\n});\nconst MASKEDINPUT_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => IMaskDirective),\n  multi: true\n};\nconst DEFAULT_IMASK_ELEMENT = elementRef => elementRef.nativeElement;\nlet IMaskDirective = /*#__PURE__*/(() => {\n  class IMaskDirective {\n    constructor() {\n      this.onTouched = () => {};\n      this.onChange = () => {};\n      this._viewInitialized = false;\n      this._composing = false;\n      this._writing = false;\n      this._elementRef = inject(ElementRef);\n      this._renderer = inject(Renderer2);\n      this._factory = inject(IMASK_FACTORY);\n      this._platformId = inject(PLATFORM_ID);\n      this._compositionMode = inject(COMPOSITION_BUFFER_MODE, {\n        optional: true\n      }) ?? !this._isAndroid();\n      this.imaskElement = DEFAULT_IMASK_ELEMENT;\n      this.accept = new EventEmitter();\n      this.complete = new EventEmitter();\n    }\n    get element() {\n      return this.imaskElement(this._elementRef, this);\n    }\n    get maskValue() {\n      if (!this.maskRef) return this.element?.value || '';\n      if (this.unmask === 'typed') return this.maskRef.typedValue;\n      if (this.unmask) return this.maskRef.unmaskedValue;\n      return this.maskRef.value;\n    }\n    set maskValue(value) {\n      if (this.maskRef) {\n        if (this.unmask === 'typed') this.maskRef.typedValue = value;else if (this.unmask) this.maskRef.unmaskedValue = value;else this.maskRef.value = value;\n      } else {\n        this._renderer.setProperty(this.element, 'value', value);\n      }\n    }\n    ngAfterViewInit() {\n      if (this.imask) this.initMask();\n      this._viewInitialized = true;\n    }\n    ngOnChanges(changes) {\n      if (changes['elementRef'] && !this.imaskElement) this.imaskElement = DEFAULT_IMASK_ELEMENT;\n      if (!changes['imask'] || !this._viewInitialized) return;\n      if (this.imask) {\n        if (this.maskRef) this.maskRef.updateOptions(this.imask);else {\n          this.initMask();\n          this.onChange(this.maskValue);\n        }\n      } else {\n        this.destroyMask();\n      }\n    }\n    destroyMask() {\n      if (this.maskRef) {\n        this.maskRef.destroy();\n        delete this.maskRef;\n      }\n    }\n    ngOnDestroy() {\n      this.destroyMask();\n      this.accept.complete();\n      this.complete.complete();\n    }\n    beginWrite(value) {\n      this._writing = true;\n      this._writingValue = value;\n    }\n    endWrite() {\n      this._writing = false;\n      return this._writingValue;\n    }\n    writeValue(value) {\n      value = value == null && this.unmask !== 'typed' ? '' : value;\n      if (this.maskRef) {\n        this.beginWrite(value);\n        this.maskValue = value;\n        this.endWrite();\n      } else {\n        this._renderer.setProperty(this.element, 'value', value);\n        this._initialValue = value;\n      }\n    }\n    _onAccept() {\n      const value = this.maskValue;\n      // if value was not changed during writing don't fire events\n      // for details see https://github.com/uNmAnNeR/imaskjs/issues/136\n      if (this._writing && value === this.endWrite()) return;\n      this.onChange(value);\n      this.accept.emit(value);\n    }\n    _onComplete() {\n      this.complete.emit(this.maskValue);\n    }\n    initMask() {\n      this.maskRef = this._factory.create(this.element, this.imask).on('accept', this._onAccept.bind(this)).on('complete', this._onComplete.bind(this));\n      if (this._initialValue != null) this.writeValue(this._initialValue);\n      delete this._initialValue;\n    }\n    setDisabledState(isDisabled) {\n      this._renderer.setProperty(this.element, 'disabled', isDisabled);\n    }\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    _handleInput(value) {\n      // if mask is attached all input goes throw mask\n      if (this.maskRef) return;\n      if (!this._compositionMode || this._compositionMode && !this._composing) {\n        this.onChange(value);\n      }\n    }\n    _compositionStart() {\n      this._composing = true;\n    }\n    _compositionEnd(value) {\n      this._composing = false;\n      this._compositionMode && this._handleInput(value);\n    }\n    _isAndroid() {\n      return isPlatformBrowser(this._platformId) && /android (\\d+)/.test(navigator.userAgent.toLowerCase());\n    }\n    static #_ = this.ɵfac = function IMaskDirective_Factory(t) {\n      return new (t || IMaskDirective)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: IMaskDirective,\n      selectors: [[\"\", \"imask\", \"\"]],\n      hostBindings: function IMaskDirective_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"input\", function IMaskDirective_input_HostBindingHandler($event) {\n            return ctx._handleInput($event.target.value);\n          })(\"blur\", function IMaskDirective_blur_HostBindingHandler() {\n            return ctx.onTouched();\n          })(\"compositionstart\", function IMaskDirective_compositionstart_HostBindingHandler() {\n            return ctx._compositionStart();\n          })(\"compositionend\", function IMaskDirective_compositionend_HostBindingHandler($event) {\n            return ctx._compositionEnd($event.target.value);\n          });\n        }\n      },\n      inputs: {\n        imask: \"imask\",\n        unmask: \"unmask\",\n        imaskElement: \"imaskElement\"\n      },\n      outputs: {\n        accept: \"accept\",\n        complete: \"complete\"\n      },\n      exportAs: [\"imask\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([MASKEDINPUT_VALUE_ACCESSOR]), i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return IMaskDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Transforms value through mask\n * Takes mask and optionally `from` and `to` pipe types.\n * Usage:\n *   value | imask:MASK_OR_MASKED:opt_from:opt_to\n * Example:\n *   {{ 2 | imask:mask }}\n*/\nlet IMaskPipe = /*#__PURE__*/(() => {\n  class IMaskPipe {\n    transform(...args) {\n      return pipe(...args);\n    }\n    static #_ = this.ɵfac = function IMaskPipe_Factory(t) {\n      return new (t || IMaskPipe)();\n    };\n    static #_2 = this.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n      name: \"imask\",\n      type: IMaskPipe,\n      pure: true,\n      standalone: true\n    });\n  }\n  return IMaskPipe;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IMaskModule = /*#__PURE__*/(() => {\n  class IMaskModule {\n    static #_ = this.ɵfac = function IMaskModule_Factory(t) {\n      return new (t || IMaskModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: IMaskModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return IMaskModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DEFAULT_IMASK_ELEMENT, DefaultImaskFactory, IMASK_FACTORY, IMaskDirective, IMaskModule, IMaskPipe, MASKEDINPUT_VALUE_ACCESSOR };\n//# sourceMappingURL=angular-imask.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}